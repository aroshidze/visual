<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaleidoscopic Fluid Simulation</title>
    <style>
        /* Basic CSS reset to remove default margin and padding */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Hide scrollbars */
            height: 100%;
            background-color: #000; /* Black background for contrast */
            cursor: none; /* Hide the cursor as we'll draw our own */
        }
        /* Style for the canvas to make it fill the entire screen */
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="optical-art-canvas"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('optical-art-canvas');
        const ctx = canvas.getContext('2d');

        // --- State Variables ---
        let width, height;
        let time = 0;
        let shockwave = 0; // For click effect
        
        // --- Interactivity State ---
        const mouse = {
            x: null,
            y: null,
            px: null, // Previous X
            py: null, // Previous Y
            speed: 0,
            isActive: false,
            isDown: false,
            radius: 150 
        };

        // --- Configuration ---
        const config = {
            particleCount: 150, // Reduced for kaleidoscope performance
            noiseScale: 0.006,
            baseSpeed: 1.0,
            attractionForce: 0.7,
            repulsionForce: 15,
            trailLength: 12,
            feedbackZoom: 1.002,
            feedbackRotate: 0.001,
            kaleidoscopeSlices: 6,
            mouseMoveWarpFactor: 0.0005, // How much mouse speed affects zoom/rotation
        };

        // --- Data-Oriented Particle Data ---
        let pX = new Float32Array(config.particleCount);
        let pY = new Float32Array(config.particleCount);
        let pSpeed = new Float32Array(config.particleCount);
        let pHistory = [];

        /**
         * A self-contained Perlin Noise function for organic movement.
         */
        const noise = (function() {
            const p = new Uint8Array(512);
            for (let i = 0; i < 256; i++) p[i] = p[i + 256] = Math.floor(Math.random() * 256);
            const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
            const lerp = (t, a, b) => a + t * (b - a);
            const grad = (hash, x, y, z) => {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            };
            return function(x, y, z) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
                x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
                const u = fade(x), v = fade(y), w = fade(z);
                const A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z;
                const B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
                return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z), grad(p[BA], x - 1, y, z)),
                                      lerp(u, grad(p[AB], x, y - 1, z), grad(p[BB], x - 1, y - 1, z))),
                               lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1), grad(p[BA + 1], x - 1, y, z - 1)),
                                      lerp(u, grad(p[AB + 1], x, y - 1, z - 1), grad(p[BB + 1], x - 1, y - 1, z - 1))));
            };
        })();

        function setup() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            pHistory = [];
            for (let i = 0; i < config.particleCount; i++) {
                pX[i] = (Math.random() - 0.5) * width;
                pY[i] = (Math.random() - 0.5) * height;
                pSpeed[i] = config.baseSpeed + Math.random() * 0.5;
                pHistory.push([]);
            }
        }
        
        function animate() {
            // FIX: Add a guard at the top of the animation loop.
            // This prevents any drawing operations from executing if the canvas has no area,
            // which resolves the "InvalidStateError" on initial load in some environments.
            if (canvas.width === 0 || canvas.height === 0) {
                requestAnimationFrame(animate); // Keep the loop going, waiting for a valid size.
                return;
            }

            ctx.globalCompositeOperation = 'source-over';
            
            // --- 1. INTERACTIVE SHOCKWAVE & FEEDBACK LOOP ---
            shockwave *= 0.95; // Dampen shockwave over time
            mouse.speed *= 0.95; // Dampen mouse speed over time
            const warp = mouse.speed * config.mouseMoveWarpFactor;
            const zoom = config.feedbackZoom + shockwave * 0.05 + warp;
            const rotate = config.feedbackRotate + shockwave * 0.02 + warp;

            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.rotate(rotate);
            ctx.scale(zoom, zoom);
            ctx.drawImage(canvas, -width / 2, -height / 2, width, height);
            ctx.restore();

            // --- 2. DYNAMIC FADING EFFECT ---
            const bgHue = time * 20;
            ctx.fillStyle = `hsla(${bgHue % 360}, 100%, 5%, 0.15)`;
            ctx.fillRect(0, 0, width, height);

            // --- 3. KALEIDOSCOPE RENDER ---
            ctx.save();
            ctx.translate(width / 2, height / 2); // Center for kaleidoscope
            
            for (let k = 0; k < config.kaleidoscopeSlices; k++) {
                ctx.rotate(Math.PI * 2 / config.kaleidoscopeSlices);
                
                ctx.globalCompositeOperation = 'lighter';
                
                // Particle Loop - physics only updated once
                if (k === 0) {
                    for (let i = 0; i < config.particleCount; i++) {
                        const angle = noise(pX[i] * config.noiseScale, pY[i] * config.noiseScale, time * 0.5) * Math.PI * 4;
                        let vx = Math.cos(angle) * pSpeed[i];
                        let vy = Math.sin(angle) * pSpeed[i];

                        if (mouse.isActive) {
                            const mx = mouse.x - width / 2;
                            const my = mouse.y - height / 2;
                            const dx = mx - pX[i];
                            const dy = my - pY[i];
                            const distSq = dx * dx + dy * dy;
                            if (distSq < mouse.radius * mouse.radius && distSq > 1) {
                                const dist = Math.sqrt(distSq);
                                const force = (mouse.radius - dist) / mouse.radius;
                                if(mouse.isDown) {
                                    vx -= (dx / dist) * force * config.repulsionForce;
                                    vy -= (dy / dist) * force * config.repulsionForce;
                                } else {
                                    vx += (dx / dist) * force * config.attractionForce;
                                    vy += (dy / dist) * force * config.attractionForce;
                                }
                            }
                        }
                        
                        pX[i] += vx;
                        pY[i] += vy;

                        const history = pHistory[i];
                        history.push({ x: pX[i], y: pY[i] });
                        if (history.length > config.trailLength) {
                            history.shift();
                        }

                        if (Math.abs(pX[i]) > width || Math.abs(pY[i]) > height) {
                            pX[i] = (Math.random() - 0.5) * width;
                            pY[i] = (Math.random() - 0.5) * height;
                            history.length = 0;
                        }
                    }
                }
                
                // Draw trails for this slice
                for (let i = 0; i < config.particleCount; i++) {
                    const history = pHistory[i];
                    if (history.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(history[0].x, history[0].y);
                        for (let j = 1; j < history.length; j++) {
                            ctx.lineTo(history[j].x, history[j].y);
                        }
                        let hue = (pX[i] * 2 + time * 200);
                        if(mouse.isDown) hue += 180;
                        ctx.strokeStyle = `hsl(${hue % 360}, 100%, 70%)`;
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }
            }
            ctx.restore();

            // --- 4. "SINGULARITY" CURSOR ---
            if (mouse.isActive) {
                const orbRadius = mouse.isDown ? 40 : 25;
                const pulse = Math.sin(time * 50) * 5 + shockwave * 20;

                // Outer distortion field
                ctx.globalCompositeOperation = 'difference';
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, orbRadius + pulse, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                // Inner energy core
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath();
                ctx.arc(mouse.x, mouse.y, Math.max(0, orbRadius / 3 + pulse / 2), 0, Math.PI * 2);
                const coreHue = time * 300;
                ctx.fillStyle = `hsl(${coreHue % 360}, 100%, 80%)`;
                ctx.fill();
            }

            time += 0.003;
            requestAnimationFrame(animate);
        }

        // --- Event Listeners ---
        function addEventListeners() {
            const updateMousePosition = (e) => {
                // FIX: Check for touch event properties first, then fallback to mouse properties.
                const newX = e.touches ? e.touches[0].clientX : e.clientX;
                const newY = e.touches ? e.touches[0].clientY : e.clientY;

                // If newX/newY are not numbers, something is wrong, so we exit.
                if (typeof newX !== 'number' || typeof newY !== 'number') return;

                if (mouse.px !== null && mouse.py !== null) {
                    const dx = newX - mouse.px;
                    const dy = newY - mouse.py;
                    mouse.speed = Math.sqrt(dx * dx + dy * dy);
                }
                
                mouse.x = newX;
                mouse.y = newY;
                mouse.px = newX;
                mouse.py = newY;
                mouse.isActive = true;
            };
            canvas.addEventListener('mousemove', updateMousePosition);
            canvas.addEventListener('touchmove', updateMousePosition, { passive: false });
            
            canvas.addEventListener('mouseleave', () => {
                mouse.isActive = false;
                mouse.px = null;
                mouse.py = null;
            });

            canvas.addEventListener('mousedown', () => { mouse.isDown = true; shockwave = 1; });
            canvas.addEventListener('mouseup', () => mouse.isDown = false);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); mouse.isDown = true; shockwave = 1; updateMousePosition(e); }, { passive: false });
            canvas.addEventListener('touchend', () => mouse.isDown = false);
            window.addEventListener('resize', setup);
        }

        // --- Initialization ---
        window.onload = function() {
            setup();
            addEventListeners();
            animate();
        };
    </script>
</body>
</html>
